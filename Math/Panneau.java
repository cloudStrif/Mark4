import java.awt.BasicStroke;import java.awt.Color;import java.awt.Cursor;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Stroke;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionListener;import java.awt.event.MouseWheelEvent;import java.awt.event.MouseWheelListener;import java.io.File;import java.io.IOException;import java.util.ArrayList;import javax.imageio.ImageIO;import javax.swing.JOptionPane;import javax.swing.JPanel;public class Panneau extends JPanel implements Metho{        /*     * Permet de changer les dimensions des axes X et Y     */    private int taille , taille2 = 0 ;        /*     * Expression d'une fonction qu'il faudra tracer     */    private String fonc = "" ;        /*     * valide si on trace ou non      */    public boolean trace = false ;            boolean confirm = false ;    private double posX , posY = 0 ;	/*	 * Tableau de points qui sera la memoire du programme	 */    ArrayList<Points> points = new ArrayList<Points>() ;    ArrayList<Points> temporaire = new ArrayList<Points>() ;    //LIste de points utile pour les polygones non reguliers    ArrayList<Points> lisp = new ArrayList<Points>() ;        ArrayList<Droitee> droit = new ArrayList<Droitee> () ;        // c'est un compteura deux pour les droites    ArrayList<Integer> bool = new ArrayList<Integer>() ;    //si false = Droite si true = Demi-droite        ArrayList<Segment> seg = new ArrayList<Segment>() ;    // Pour le crayon a dessin        ArrayList<Dott> doot = new ArrayList<Dott>();    ArrayList<Imagee> imag = new ArrayList<Imagee>() ;            ArrayList<Triangle> trig = new ArrayList<Triangle>() ;        ArrayList <Cercl> cer = new ArrayList<Cercl>() ;        ArrayList<Polygone> paul = new ArrayList<Polygone>() ;    ArrayList<Rectangle> rect = new ArrayList<Rectangle>() ;        //Conteneur de d'objets selectionnés par la souris             ArrayList <Object> selection = new ArrayList<Object>() ;        int memo = 0;    //sert a la validation lors du dessin des formes    public boolean sta = true ;        public boolean stat = true ;        public boolean stati = false ;    //Boutons en questions    public boolean [] bou = new boolean[20];	    Color r = Color.blue ;        // sert pour la bissectrice    private  int veri = 0 ;        // Variables propre aux zoom des axes ,elles permettent le zoom a l'origine de mon graphique    private double oi  = 6 ;	private double io = 8 ;        // calculs de conversions pour le zoomage    private double zo1 =1 ;    private double zo2 = 1 ;      	//zoomage de depart    double [] z1 = {0.3 , 0.5 , 0.8,1};    double [] z2 =  {0.4 ,0.4 , 0.8, 1} ;    public  int incremen = 3 ;    //affichage de graphe les valeurs -1 ,0,1 ..     int nom = -4 ;    int nom2 = 3;    //Taille de la barre X  , en commançant par le debut    private int lenx = 8 ;    private int leny = 6 ;    //sert a la mise en scene    private boolean repet2 = true ;    /*     * capacité du conteneur      */    private int [] tx = new int [3] ;    private int [] ty = new int [3] ;    private int [] tx2 = new int [4] ;    private int [] ty2 = new int [4] ;	int [] cx = new int [4];	int [] cy = new int [4];        boolean depart =false;    private int count = 0 ;    int memoire = 0;    Brui faok ;    Brui alter = new Brui("alter",true);        Appli re ;    boolean plein = false ;    boolean regulier = false;               public Panneau(Appli f){	    re=f ;       		this.addMouseListener(new MouseAdapter(){		public void mousePressed(MouseEvent e){		    if(bou[0]){		    	if(io <= 8 && oi <= 6){			    	points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] ,0 ));				}else{			    	points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2  ,0));				}		    	 alter.jou() ;		    }		    		    //droite		    if(bou[1]){			if(sta){			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,1));			    }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2,1 ));			    }			  alter.jou() ;			    sta = false ;			}			else {			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,1));			    }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,1 ));			    }			    			    droit.add(new Droitee(points.get(points.size()-2 ), points.get(points.size()-1),"droite" )  );			    //bool.add(false);			    faok.jou() ;			    bool.add(1);			    sta = true ;			}  		    }		    		    //Demi droite		    if(bou[4]){			if(sta){			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,988));			    }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,988 ));				    		  }			    sta = false ;			}			else {			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,988));			    }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,988 ));			    }			    			    droit.add(new Droitee(points.get(points.size()-2 ), points.get(points.size()-1),"demi" )  );			    // bool.add(true);			    faok.jou() ;			    bool.add(0);			    sta = true ;			}  		    }			    	  		    // Mediatrice 		    if(bou[5]){			if(sta){			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] ,999));				    		  }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,999 ));			    }			    			    			    sta = false ;			}			else {			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] ,999));			    }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2  ,999));			    }			    droit.add(new Droitee(points.get(points.size()-2 ), points.get(points.size()-1) ,"media")  );			    			    faok.jou() ;			    bool.add(2);			    sta = true ;			}  		    }		    		    		    //Bissectrice		    if(bou[2]){			if(sta){			    veri ++ ;			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] ,2 ));			    }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,2 ));			    }			    if(veri == 2){				sta = false ;				veri = 0 ;			    }			}			else {			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen],2  ));			    }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,2 ));			    }			    			    	droit.add(new Droitee(points.get(points.size()-3) ,points.get(points.size()-2 ), points.get(points.size()-1) )  );			    			    	faok.jou() ;			    	bool.add(3);			    	sta = true ;			    				}  		    }		    		    		    		    		    // segment		    if(bou[3]){			if(stat){			    if(io <= 8 && oi <= 6){				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen],3 ));				    		  }else{				points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,3 ));			    } 			    stat = false ;			}			else {			    if(io <= 8 && oi <= 6){			    	points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] , 3));			    }else{			    	points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,3 ));			    }			    	seg.add(new Segment(points.get(points.size()-2 ), points.get(points.size()-1) )  );			    	stat = true ;				}  						    faok.jou() ;		    }		    //dessin		    if(bou[7])		    	doot.add(new Dott(e.getX() , e.getY() , 10 , r));		 		    //image		    if(bou[8]){		    			    		JOptionPane jop = new JOptionPane(), jop2 = new JOptionPane();		    		String nom = jop.showInputDialog(null, "Entrer le nom et format de l'image",		    				"Image chargé",		    		JOptionPane.QUESTION_MESSAGE);		    			    		imag.add(new Imagee(e.getX() , e.getY() ,nom , 300 ,300));		    }		    //TRIANGLE		    if(bou[9]){		    		    					if(sta){				    veri ++ ;				    if(io <= 8 && oi <= 6){					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] ,4 ));				    }else{					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,4 ));				    }				    if(veri == 2){					sta = false ;									veri = 0 ;				    }				}				else {				    if(io <= 8 && oi <= 6){					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen],4  ));				    }else{					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,4 ));				    }				    				    trig.add(new Triangle(points.get(points.size()-3) ,points.get(points.size()-2),points.get(points.size()-1),r ));				    				    faok.jou() ;				//Inserer				    sta = true ;				    				}		    }		    if(bou[10]){		    	isobary() ;		    	repaint() ;		    }		    		    //CERCLES		    if(bou[11]){		    	if(sta){				    if(io <= 8 && oi <= 6){					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,7));				    }else{					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2,7 ));				    }				    				    sta = false ;				}				else {				    if(io <= 8 && oi <= 6){					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,7));				    }else{					points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,7 ));				    }				   Cercl cle = new Cercl(points.get(points.size()-2) , points.get(points.size()-1) , r) ;				  				   cer.add(cle);				  // cle.setRayon(  (int) (points.get(points.size()-2).getXx() - points.get(points.size()-1).getXx())  )  ;				   				   //cer.add(new Cercl(points.get(points.size()-2) , points.get(points.size()-1) , r) ) ;				    				    				  //droit.add(new Droitee(points.get(points.size()-2 ), points.get(points.size()-1),"droite" )  );				   // poi				    				   faok.jou() ;				    sta = true ;				}  		    			    }		    		    //Polygone Regulier et pas regulier		    if(bou[12]){		    	if(!regulier){		    					JOptionPane jop = new JOptionPane(), jop2 = new JOptionPane();	    		String nom = jop.showInputDialog(null, "combien de coté ? ",	    				"Polygone regulier",	    		JOptionPane.QUESTION_MESSAGE);	    			    		int taille = Integer.parseInt(nom);	    		Polygone poly ;	    		if(io <= 8 && oi <= 6){		    		 poly = new Polygone(taille ,z1[incremen],z2[incremen] , (posX/z1[incremen]/0.01)+taille/2 ,(-posY/z2[incremen]/0.01)+ (taille2-100)/2);	    		paul.add(poly);	    		}else{		    		 poly =new Polygone(taille ,zo1,zo2 ,(posX/zo1/0.01)+taille/2 ,(-posY/zo2/0.01)+ (taille2-100)/2);	    			paul.add(poly);		    		}		    			    		for(int i =0 ; i < poly.dot.length ; i++){	    			points.add(poly.dot[i]);	    		}		    	}else{		    		stati=true ;					    if(io <= 8 && oi <= 6){						points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,98));					    temporaire.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen]  ,98));					    }else{						points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2,98 ));					    temporaire.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2,98 ));					    }					    if(points.size()>1){					    						  					    						    	if(points.get(points.size()-1).getX() <= points.get(points.size()-2).getX()+40 					    			&& points.get(points.size()-1).getX() >= points.get(points.size()-2).getX()-40 					    			&& points.get(points.size()-1).getY() <= points.get(points.size()-2).getY()+40 					    			&& points.get(points.size()-1).getY() >= points.get(points.size()-2).getY()-40 ){					    		stati=false;					    		//sta=false ;					    		lisp = new ArrayList<Points>() ;				    			for(int  i =memoire ; i < points.size() ; i++){				    				if(points.get(i).getVeri() == 98){				    					lisp.add(points.get(i));				    					//memoire=i+1 ;				    									    					memoire=i;				    				}				    			}				    			if(lisp.size()!=0){				    			lisp.remove(lisp.size()-1);				    			points.remove(points.size()-1);				    			}				    						    			paul.add(new Polygone(lisp,r));				    							    			temporaire = new ArrayList<Points>();				    			repaint() ;					    	}					    }					    		    				    			    			    	}	    				    }		    		    if(bou[13]){		    	/*		    	 * On change le curseur pour celui de la main qui regarde.		    	 */		    			  	 setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));				if(select(e.getX() , e.getY())){					for(int i =0 ; i < points.size() ; i++){						if(points.get(i).equals(selection.get(selection.size()-1))){						memo = i ;						}					}																			}		   		    			    }		    		    if(bou[14]){		    	count ++ ;		    	if(io <= 8 && oi <= 6){			    	points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] ,100 ));			    	points.add(new Points(((int)e.getX()-6)+60, ((int)e.getY() - 6)+30,z1[incremen], z2[incremen] ,101 ));				}else{			    	points.add(new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2  ,100));			    	points.add(new Points(((int)e.getX()-6)+60, ((int)e.getY() - 6)+30,zo1, zo2  ,101));				}		    	if(count == 4){		    		count=0;		    		rect.add(new Rectangle(points.get(points.size()-8),points.get(points.size()-6),points.get(points.size()-4),points.get(points.size()-2),r ));		    		rect.add(new Rectangle(points.get(points.size()-7),points.get(points.size()-5),points.get(points.size()-3),points.get(points.size()-1),r ));		    	}		    			    }		    		    		    repaint() ;		    re.aff.setTexte(Discription());		}	    });			this.addMouseMotionListener(new MouseMotionListener(){		public void mouseDragged(MouseEvent e) {					if(bou[13]){			/*	Deplacement d'une droite 			 * 			 * int memm=0 ;				int memm1 = 0 ;				if(selection.get(selection.size()-1) instanceof Droitee){					for(int icar=0 ; icar < droit.size() ; icar ++){						if(droit.get(icar).equals(selection.get(selection.size()-1))){							memm=icar ;						}					}										for(int i = 0; i < points.size() ; i++){						if(droit.get(memm).getDep().equals(points.get(i))){							memm1=i ;							Points tmp1 , tmp2 ;							tmp1=points.get(i);							tmp2=points.get(i+1);							int re1 = Math.abs(e.getX() - tmp1.getX());							int re2 = Math.abs(e.getY() - tmp1.getY());							int re3 = Math.abs(e.getX() - tmp2.getX());							int re4 = Math.abs(e.getY() - tmp2.getY());							tmp1.setX(tmp1.getX()+re1);							tmp1.setY(tmp1.getX()+re2);							tmp2.setX(tmp2.getX()+re3);							tmp2.setX(tmp2.getX()+re4);							points.remove(i);							points.remove(i+1);							points.set(i , tmp1);							points.set(i+1 , tmp2);							break ;						}					}															droit.remove(memm);					droit.set(memm , new Droitee(points.get(memm1),points.get(memm1),"droite"));					repaint();				}*/															points.remove(memo);						  if(io <= 8 && oi <= 6){								points.add(memo,new Points(((int)e.getX()-6), ((int)e.getY() - 6),z1[incremen], z2[incremen] ,999));								    		  						  }else{								points.add(memo,new Points(((int)e.getX()-6), ((int)e.getY() - 6),zo1, zo2 ,999 ));						  }						  												repaint() ;															}								    if(bou[7])			   doot.add(new Dott(e.getX() , e.getY() , 10 , r));			  						  repaint() ;			  		    		}			public void mouseMoved(MouseEvent e) {		 		    			confirm=false ;		    		   			if(bou[10]){				isobary() ;			}							    if(bou[6]){		    			    	if(points.size()!=0)		    		points.remove(points.size()-1);		    	  if(io <= 8 && oi <= 6){		    		  points.add(droit.get(0).inter(droit.get(1) , z1[incremen] , z2[incremen]));		    	  }else{		    		  points.add(droit.get(0).inter(droit.get(1) , zo1 , zo2));		    	  }		    	  repaint();		    	  		    }						  			    	  		    if(io <= 8 && oi <= 6){			posX = ((e.getX() - taille/2 )*0.01 )*z1[incremen];			//	System.out.println(io +"  et  "+ oi);			posY = ((-( e.getY() - (taille2-97)/2))*0.01)*z2[incremen] ;					    }else {						posX = ((e.getX() - taille/2)*0.01 )*zo1;			posY = ((-( e.getY() - (taille2-97)/2))*0.01)*zo2 ;		    }		    		    repaint() ;		    		   		      		   setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));			   		   if(repet2){			  faok = new Brui("grap" ,true) ;			   faok.jou() ;			   repet2 = false ;		   }else{			   re.aff.setTexte(Discription());		   }				   		   // re.pack() ;		  //  Cursor.MOVE_CURSOR SI on deplace une figure passer par la		    		}									    });		this.addMouseWheelListener (new MouseWheelListener (){		public void mouseWheelMoved(MouseWheelEvent e) { 					    int notches = e.getWheelRotation(); 		  		    if (notches < 0){		    				if(io >= 0 && oi >= 0){								io = io - 2 ;			    oi = oi -2 ;			    			    			}			if(io < 8 && oi < 6){			    zo1 = zo2 = 1 ;			    if(incremen != 0 )				incremen = incremen - 1 ;						}else {			    zo1 = zo1 - 0.3 ;			    zo2 = zo2 - 0.3 ;		    }									nom ++ ;			nom2--;						lenx -= 2 ;			leny -=2 ;									zoomage() ;									repaint() ;		    }		    else{						    						if(io < 8 && oi < 6){			    zo1 = zo2 = 1 ;			    if(incremen != 3)				incremen = incremen + 1 ;			}else {			    zo1 = zo1 + 0.3 ;			    zo2 = zo2 + 0.3 ;			}									io = io + 2 ;			oi = oi +2 ;									nom --;			nom2 ++;						lenx += 2 ;			leny+=2;			zoomage() ;			repaint() ;		    }				} 				   	    });	    }    /*     * Fonction d'affichage de depart     */    public void clone(boolean b){    	 if (b){ 			if(io >= 0 && oi >= 0){ 				io = io - 2 ; 			    oi = oi -2 ;     			} 			if(io < 8 && oi < 6){ 			    zo1 = zo2 = 1 ; 			    if(incremen != 0 ) 				incremen = incremen - 1 ; 			 			}else { 			    zo1 = zo1 - 0.3 ; 			    zo2 = zo2 - 0.3 ; 		    } 			 			nom ++ ; 			nom2--; 			 			lenx -= 2 ; 			leny -=2 ; 			 			 			zoomage() ; 			repaint() ; 		    }    	 else{ 			if(io < 8 && oi < 6){ 			    zo1 = zo2 = 1 ; 			    if(incremen != 3) 				incremen = incremen + 1 ; 			}else { 			    zo1 = zo1 + 0.3 ; 			    zo2 = zo2 + 0.3 ; 			} 			io = io + 2 ; 			oi = oi +2 ;	 			nom --; 			nom2 ++; 			lenx += 2 ; 			leny+=2; 			zoomage() ; 			repaint() ; 		    } 		     		        }                                /*     * Methode qui renvoie une discription des coordonnées des points     */        public String Discription(){	String po = "COORDONNEES POINTS \n\n";		for(int i = 0 ; i < points.size() ; i++){						if(points.get(i).getVeri()!=50 )				po = po + "Point "+ i + "  (" + points.get(i).getXx() +" , "+ points.get(i).getYy() +" )" +"\n" ;					}				po = po + "\n\n DROITES EQUATIONS  \n\n" ;		for(int i = 0; i  < droit.size() ; i++){			po = po + droit.get(i).getA() +"X + " +droit.get(i).getB() +"Y = " + droit.get(i).getC() + "\n";		}		po = po +  " \n\n  SEGMENTS \n\n";				for(int i = 0; i  < seg.size() ; i++){			if(seg.get(i).getMatrice()!=1)			po = po + "Distance "+i +seg.get(i).Long() + "\n";		}				po = po + " \n\n  Cercles \n\n";		for(int i  =0 ; i < cer.size() ; i++){						po = po + "\n Rayon cercle  = " +cer.get(i).getRayon();			po = po + "\n Perimetre de cercle = " + cer.get(i).perimetre() ;			po = po + "\n Rayon du cercle = " + cer.get(i).surface() ;			po = po + "\n Couleur cercle = " + cer.get(i).getCo() +"\n\n";		}				po = po + "\n\n Triangulation  \n\n";		for(int i  = 0 ; i < trig.size() ; i++){						po = po+ "\n Couleur : " + trig.get(i).co ;			po = po + "\n Perimetre :  " + trig.get(i).perimetre() ;					}						po = po +"\n\n Fonctions : \n\n" ;		po = po + re.getFonction() +"\n";				po = po + " \n\n  POLYGONES \n\n";				for(int i= 0 ; i < paul.size() ; i++){			po = po + "\n Perimetre = "+ paul.get(i).perimetre() ;			po = po + "\n Aire relative = "+ paul.get(i).surface() ;			po = po + "\n Liste des points qui le compose : "+ paul.get(i	).cord() ;		}				    	return po ;    }            public void graphe(Graphics g){	g.setColor(Color.green);	g.drawLine(((int)(taille/2))  , 0 ,  ((int)(taille/2)) , taille2 - 80 );	g.drawLine(0 , ((int)((taille2 /2)-60)) , taille ,  ((int)((taille2 /2)- 60) ));		/*	 * Graduation du graphe	 */		int a = nom ;			int b =  nom2 ;			for(int ii = 0 ; ii < taille ; ii = ii + ((int)(taille/io))){	    g.drawLine(ii , ((int)(taille2/2) -50) , ii ,  ((int)(taille2/2))-70 ) ;			g.drawString(a+"" ,ii , ((int)(taille2/2)-45)	);			a++ ;	}		for(int jj = 0 ; jj < taille2 ; jj = jj + ((int)(528/oi))){	    g.drawLine( (int)(taille/2) -5, jj , (int)(taille/2)+5 , jj  );			g.drawString(b+"" , (int)(taille/2)+5 ,jj);			b-- ;				}			g.setColor(Color.blue);				g.drawString(" Coordonnée X :  " +Double.toString(posX) , 10,10 );		g.drawString(" Coordonnée Y :  " +Double.toString(posY) , 10,20 );						    }        public void zoomage(){	if(depart){    	seg = new ArrayList<Segment>() ;    	matrix() ;	}		//On vide la selection de pile	//selection = new ArrayList<Object>();			for(int pp =0 ; pp < points.size() ; pp++){	    int tmp ,tmp2 ;				    double t ,t2 =0 ;	    	    double Xx ,Yy;	    	    tmp = ((int)(800 / lenx)) ;	    	    tmp2 = ((int)(530 / leny)) ;				 	    	    t = lenx/2 + (points.get(pp).getXx()) ;	    	    t2 = leny/2  - (points.get(pp).getYy()) ;	    	    	  	    Xx = points.get(pp).getXx() ;	    Yy = points.get(pp).getYy() ;	    	    int boo = points.get(pp).getVeri() ;	  	 /*   if(io <= 8 && oi <= 6){	          points.set(pp , new Points(  ((int)(tmp*t)) , ((int)(tmp2*t2)),z1[incremen],z2[incremen] ,boo));	    }else{	    	  points.set(pp , new Points(  ((int)(tmp*t)) , ((int)(tmp2*t2)),zo1,zo2 ,boo));		    }*/	    points.set(pp , new Points(  ((int)(tmp*t)) , ((int)(tmp2*t2)),1,1 ,boo));		    	    	    points.get(pp).setXx(Xx);	    points.get(pp).setYy(Yy);		}	/*	 * Le recalcul des droites	 */	int crave = 0 ;			for(int i = 0 ; i <droit.size() ; i++){						//droite simple			if(bool.get(i)== 1)			{						for(int k = crave ; k < points.size() ; k++){					if(points.get(k).getVeri() == 1 ){					droit.set(i , new Droitee(points.get(k) , points.get(k+1) , "droite"));					crave = k +2;					break ;					}																			}			}			//mediatrice			if(bool.get(i)== 2){				for(int k = crave ; k < points.size() ; k++){					if(points.get(k).getVeri() == 999){					droit.set(i , new Droitee(points.get(k) , points.get(k+1) , "media"));					crave = k + 2;					break ;					}				}						}			//Bissectrice			if(bool.get(i) == 3){				for(int k = crave ; k < points.size() ; k++){					if(points.get(k).getVeri() == 2){					droit.set(i , new Droitee(points.get(k) , points.get(k+1) ,points.get(k+2)));					crave = k + 3;					break ;					}				}			}			if(bool.get(i) == 0){				for(int k = crave ; k < points.size() ; k++){					if(points.get(k).getVeri() == 988){					droit.set(i , new Droitee(points.get(k) , points.get(k+1),"demi"));					crave = k + 2;					break ;					}				}			}		}		crave =0 ;				for(int yy = 0 ; yy < seg.size() ; yy++){			for(int ll = crave ; ll < points.size() ; ll++){				if(points.get(ll).getVeri() == 3){					seg.set(yy,new Segment(points.get(ll), points.get(ll+1)));					crave = ll + 2 ;					break ;				}			}		}		crave =0 ;				//TRIANGLE		for(int p = 0 ; p < trig.size() ; p++){			for(int lo = crave ; lo < points.size() ; lo ++){				if(points.get(lo).getVeri() == 4){					trig.set( p, new Triangle(points.get(lo) ,points.get(lo+1),points.get(lo+2) ,trig.get(p).co )) ;					crave = lo + 3 ;					break ;				}			}		}			    						crave =0 ;		//CIRCLE		for(int pr = 0 ; pr < cer.size() ; pr ++){			for(int loo = crave  ; loo < points.size() ; loo++){				if(points.get(loo).getVeri() == 7){					cer.set(pr , new Cercl(points.get(loo) , points.get(loo+1) , cer.get(pr).getCo()));					crave  = loo + 2 ;					break ;				}			}		}		crave = 0 ;		//CUBIC				for(int ad = 0 ; ad < rect.size() ; ad++){			for(int del = crave ; del < points.size() ; del++){				if(points.get(del).getVeri()==100){					rect.set(ad , new Rectangle(points.get(del) ,points.get(del+2),points.get(del+4),points.get(del+6),rect.get(ad).getCo()));					rect.set(ad+1 , new Rectangle(points.get(del+1) ,points.get(del+3),points.get(del+5),points.get(del+7),rect.get(ad).getCo()));					crave = del +8 ;					break ;				}						}		}						crave=0;				//polygone regulier				for(int pi = 0 ; pi < paul.size() ; pi++){				for(int low = crave ; low < points.size() ; low++){					if(points.get(low).getVeri() == 42 || points.get(low).getVeri() == 98){																		Points [] tab = new Points[paul.get(pi).size];						int iii = 0 ;						for(int uz = low ; uz < points.size() ; uz++){							if(iii == paul.get(pi).size)								break ;							tab[iii] = points.get(uz) ;														//tab[iii].setVeri(42);							//tab[iii].setVeri(98);							iii++;						}						crave = low + paul.get(pi).size ;												paul.set(pi ,new Polygone(tab,r));																	break ;					}				}			}    }    /*     * Fonction qui compte le nombre de points liés a des polygones     */    public int conte(){    	int o=0 ;    	for(int i = 0 ; i < points.size() ; i++)    		if(points.get(i).getVeri() == 10)    			o++;    	    	return o ;    }    /*     *Fonction qui place le barycentre     */    public void isobary() {    	double a = 0, b = 0 ;    	double com = 0 ;    	for(int  i =0 ; i < points.size() ; i++){    		if(points.get(i).getVeri() == 0){    			a = a + points.get(i).getX() ;    			b = b + points.get(i).getY() ;    			com ++ ;    		}    	}    	a = a / com ;    	b = b / com ;    	if(io <= 8 && oi <= 6){	    	points.add(new Points((int)(a), (int)(b),z1[incremen], z2[incremen] ,0 ));		}else{	    	points.add(new Points((int)(a),(int)(b),zo1, zo2  ,0));		}    	repaint() ;    }    /*     * Fonction qui met en pause le programme      */	public void pause (int a){		  try {	            Thread.sleep(a);	          } catch (InterruptedException e) {	            e.printStackTrace();	          }		}        public void paintComponent(Graphics g2){				/*	Graphics2D g2 = (Graphics2D) g;				g2.scale(io , oi);		*/        	   	  Graphics2D g = (Graphics2D) g2;  	/*  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,                 RenderingHints.VALUE_ANTIALIAS_ON);*/  	   	     	 		   	  g.setColor(new Color(20,20,20));   	    	  g.fillRect(0,0,1000,1000);				if(trace){	    	 	    	    g.setColor(Color.red);	    g.drawLine(Integer.parseInt(fonc), taille2 , Integer.parseInt(fonc) ,0 );		    repaint() ;	    	  	}				//nescessaire pour la methode repaint()	g.setColor(new Color(20,20,20)) ;		g.fillRect(0 , 500 , 800 , 100) ;		graphe(g) ;					for(int pp =0 ; pp < points.size() ; pp++){	    	    	    			g.setColor(points.get(pp).getColor());			g.fillOval((points.get(pp).getX()) , (points.get(pp).getY()) , 12, 12);			g.setColor(Color.green);								//g.drawString("(  " + Double.toString(points.get(pp).getXx()) 				//     +" , "+ Double.toString(points.get(pp).getYy())+" )",(points.get(pp).getX())-50 , (points.get(pp).getY()));												//	g.drawString("(  " + Double.toString(points.get(pp).getX()) 			//		+" , "+ Double.toString(points.get(pp).getY())+" )",(points.get(pp).getX()) , (points.get(pp).getY()+40));	}			if(bou[1]){		    if(!sta){			g.setColor(Color.green);			/*			 * ligne pas encore tracé			 */			double coeffa =0 ;			try{			if(io <= 8 && oi <= 6){			    coeffa = ( (-posY/z2[incremen]/0.01)+ (taille2-100)/2 - (points.get(points.size() - 1 ).getY()+6 ) )/ ( (posX/z1[incremen]/0.01)+ taille/2 -																(points.get(points.size() - 1 ).getX() +6)) ;			    			    double ff = (posX/z1[incremen]/0.01)+taille/2;			    //System.out.println("X "+ ff);			}else {			    coeffa = ( (-posY/zo2/0.01)+ (taille2-100)/2 - (points.get(points.size() - 1 ).getY()+6 ) )/ ( (posX/zo1/0.01)+ taille/2 -														       (points.get(points.size() - 1 ).getX() +6)) ;						}			}catch(Exception e ){}						double coeffb = ( points.get(points.size() - 1).getY()+6) - coeffa * (points.get(points.size() - 1).getX()+6) ;						//System.out.println(coeffa+"  et  " + coeffb);						g.drawLine(-2 , (int)(coeffa*-2 + coeffb) , 800 , (int)(800*coeffa +coeffb) ) ;												points.get(points.size() -1).min = (int)(coeffa*-2 + coeffb);		//	System.out.println(points.get(points.size() -1).min +"  =  MIN"); 			points.get(points.size() - 1).max = (int)(800*coeffa +coeffb) ;									//	sur =  (int)(coeffa*-2 + coeffb) ;			//	sur2 = (int)(800*coeffa +coeffb);						/*					g.drawLine(points.get(points.size() - 1  ).getX()  , points.get(points.size() - 1  ).getY()				,(int)((posX/0.01)+ taille/2),(int)((-posY/0.01)+ (taille2-100)/2) ) ;			*/		    }		    		    		}				if(bou[4]){		    if(!sta){			g.setColor(Color.orange);			/*			 * ligne pas encore tracé			 */						double coeffa = 0 ;			try{			if(io <= 8 && oi <= 6){			    coeffa = ( (-posY/z2[incremen]/0.01)+ (taille2-100)/2 - (points.get(points.size() - 1 ).getY()+6)  )/ ( (posX/z1[incremen]/0.01)+ taille/2 -																(points.get(points.size() - 1 ).getX()+6) ) ;			}else {				 			    coeffa = ( (-posY/zo2/0.01)+ (taille2-100)/2 - (points.get(points.size() - 1 ).getY()+6)  )/ ( (posX/zo1/0.01)+ taille/2 -														       (points.get(points.size() - 1 ).getX()+6) ) ;			}			}catch(Exception e ){}			double coeffb = ( points.get(points.size() - 1).getY()+6) - coeffa * (points.get(points.size() - 1).getX()+6) ;						//System.out.println(coeffa+"  et  " + coeffb);												points.get(points.size() -1).min = (int)(coeffa*-2 + coeffb);			points.get(points.size() - 1).max = (int)(800*coeffa +coeffb) ;						if(io <= 8 && oi <= 6){			    if(points.get(points.size() -1).getX() < (posX/z1[incremen]/0.01)+taille/2 ){				g.drawLine((points.get(points.size() - 1  ).getX()+6 ) , (points.get(points.size() - 1  ).getY()+6) , 					   800 , (int)(800*coeffa +coeffb) ) ;				}else {				// n				g.drawLine(-2 , (int)(-2*coeffa +coeffb), points.get(points.size() - 1  ).getX() +6 , points.get(points.size() - 1  ).getY()+6);								}			    			    			}else {			    			    if(points.get(points.size() -1).getX() < (posX/zo1/0.01)+taille/2 ){				g.drawLine((points.get(points.size() - 1  ).getX()+6)  ,( points.get(points.size() - 1  ).getY()+6) , 					   800 , (int)(800*coeffa +coeffb) ) ;			    }else {				// n				g.drawLine(-2 , (int)(-2*coeffa +coeffb), (points.get(points.size() - 1  ).getX() +6) , (points.get(points.size() - 1  ).getY()+6));								    }			    			   }		    }		}						if(bou[3]){			if(!stat){			    g.setColor(Color.gray);			    /*			     * ligne pas encore tracé			     */			    						    			    			    if(io <= 8 && oi <= 6){				g.drawLine(points.get(points.size() - 1  ).getX()  , points.get(points.size() - 1  ).getY()					   ,(int)((posX/z1[incremen]/0.01)+ taille/2),(int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2) ) ;			    }else {								g.drawLine(points.get(points.size() - 1  ).getX()  , points.get(points.size() - 1  ).getY()					   ,(int)((posX/zo1/0.01)+ taille/2),(int)((-posY/zo2/0.01)+ (taille2-100)/2) ) ;											    }			}							}								for( Segment ss : this.seg){		    g.setColor(Color.green);		    		    g.drawLine(ss.getDep().getX()+6 , ss.getDep().getY()+6 , ss.getAr().getX()+6 ,ss.getAr().getY() +6);		    if(ss.getMatrice()!=1)		    g.drawString("Distance = " +ss.Long() ,ss.getDep().getX()-20 ,ss.getDep().getY()- 40  );		    		    		}				//polygon		if(bou[12]){			if(regulier){							g.setColor(r);			int []xxx = new int[temporaire.size()+1];			int []yyy = new int[temporaire.size()+1];				for(int i= 0 ; i < temporaire.size() ; i++){					xxx[i]=temporaire.get(i).getX();					yyy[i]=temporaire.get(i).getY();				}				if(io <= 8 && oi <= 6){						xxx[temporaire.size()] = (int)((posX/z1[incremen]/0.01)+ taille/2) ;					yyy[temporaire.size()] = (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2);				}else {					xxx[temporaire.size()] = (int)((posX/zo1/0.01)+ taille/2) ;					yyy[temporaire.size()] = (int)((-posY/zo2/0.01)+ (taille2-100)/2);				}								if(stati)				g.drawPolygon(xxx,yyy,xxx.length);							}		}								//Mediatrice 		if(bou[5]){		    if(!sta){						double a,b,c = 0 ;						//Grace au produit scalaire on a Vector1 = -b , a pour Vector2 = a , b						if(!points.isEmpty()){			    			    if(io <= 8 && oi <= 6){					a =   (int)((posX/z1[incremen]/0.01)+ taille/2) - (points.get(points.size() - 1).getX()+6)  ;								b =   (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2)  - (points.get(points.size() - 1).getY()+6) ;								c = -a * (  ((int)((posX/z1[incremen]/0.01)+ taille/2)  +  (points.get(points.size() - 1).getX()+6) )/2   ) +				    -b* ( ( (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2) + (points.get(points.size() - 1).getY()+6)) /2) ;							    }else {				a =   (int)((posX/zo1/0.01)+ taille/2) - (points.get(points.size() - 1).getX()+6)  ;								b =   (int)((-posY/zo2/0.01)+ (taille2-100)/2)  - (points.get(points.size() - 1).getY()+6) ;								c = -a * (  ((int)((posX/zo1/0.01)+ taille/2)  +  (points.get(points.size() - 1).getX()+6) )/2   ) +				    -b* ( ( (int)((-posY/zo2/0.01)+ (taille2-100)/2) + (points.get(points.size() - 1).getY()+6)) /2) ;											    }			    double coeffa =  -(a / b) ;			    			    double coeffb = - c / b ;			    			    g.drawLine(-2 , (int)(coeffa*-2 + coeffb) , 800 , (int)(800*coeffa +coeffb) ) ;					    			    points.get(points.size() -1).min = (int)(coeffa*-2 + coeffb);			    points.get(points.size() - 1).max = (int)(800*coeffa +coeffb) ;			    			    			}		    }		    		}				//cubique		if(bou[14]){						if(count == 3){											g.setColor(r);				tx2[0] = points.get(points.size()-6).getX()+6 ;				ty2[0] = points.get(points.size()-6).getY()+6 ;				cx[0]  = points.get(points.size()-5).getX()+6  ;				cy[0]  = points.get(points.size()-5).getY()+6 ;								g.drawLine(cx[0] , cy[0] , tx2[0], ty2[0]);								tx2[1] = points.get(points.size()-4).getX()+6 ;				ty2[1] = points.get(points.size()-4).getY()+6 ;				cx[1]  = points.get(points.size()-3).getX()+6 ;				cy[1]  = points.get(points.size()-3).getY()+6 ;								g.drawLine(cx[1] , cy[1] , tx2[1], ty2[1]);								tx2[2] = points.get(points.size()-2).getX()+6 ;				ty2[2] = points.get(points.size()-2).getY()+6 ;				cx[2]  = points.get(points.size()-1).getX()+6 ;				cy[2]  = points.get(points.size()-1).getY()+6 ;								g.drawLine(cx[2] , cy[2] , tx2[2], ty2[2]);								if(io <= 8 && oi <= 6){						tx2[3] = (int)((posX/z1[incremen]/0.01)+ taille/2) ;					ty2[3] = (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2);					cx[3] = (int)((posX/z1[incremen]/0.01)+ taille/2) +60;					cy[3] = (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2)+30;				}else{					tx2[3] = (int)((posX/zo1/0.01)+ taille/2) ;					ty2[3] = (int)((-posY/zo2/0.01)+ (taille2-100)/2);					cx[3] = (int)((posX/zo1/0.01)+ taille/2) +60;					cy[3] = (int)((-posY/zo2/0.01)+ (taille2-100)/2)+30;				}				g.drawLine(cx[3] , cy[3] , tx2[3], ty2[3]);								if(!plein){					g.drawPolygon(tx2 , ty2 , 4);					g.drawPolygon(cx , cy , 4);								}else{					g.fillPolygon(tx2 , ty2 , 4);					g.fillPolygon(cx , cy , 4);				}			}								}				//triangle		if(bou[9]){			if(!sta){				g.setColor(r);					tx[1] = points.get(points.size()-1).getX()+6 ;					ty[1] = points.get(points.size()-1).getY() +6;				if(io <= 8 && oi <= 6){						tx[2] = (int)((posX/z1[incremen]/0.01)+ taille/2) ;					ty[2] = (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2);				}else {					tx[2] = (int)((posX/zo1/0.01)+ taille/2) ;					ty[2] = (int)((-posY/zo2/0.01)+ (taille2-100)/2);				}				if(!plein)					g.drawPolygon(tx , ty , 3);				else					g.fillPolygon(tx , ty , 3);			}else {				if(points.size()!= 0){				tx[0] = points.get(points.size()-1).getX() +6;				ty[0] = points.get(points.size()-1).getY() +6;				}			}		}		//CIRCLE		if(bou[11]){			 if(!sta){				 g.setColor(r);						int a , b = 0 ;				 if(io <= 8 && oi <= 6){							 a  = ( (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2) >= points.get(points.size() -1).getY()  ) ?								Math.abs(  (int)(((-posY/z2[incremen]/0.01)+ (taille2-100)/2)+6) - ( points.get(points.size() -1).getY()+6) ) :									Math.abs((points.get(points.size()-1).getY()+6) - (int)(((-posY/z2[incremen]/0.01)+ (taille2-100)/2)+6)) ;														b  = ((int)((posX/z1[incremen]/0.01)+ taille/2) >= points.get(points.size() -1).getX() ) ?								Math.abs(((int)((posX/z1[incremen]/0.01)+ taille/2)+6) - (points.get(points.size()-1).getX()+6)) :									Math.abs((points.get(points.size()-1).getX()+6) - ((int)((posX/z1[incremen]/0.01)+ taille/2)+6) )									;													}else{						 a  = ( (int)((-posY/zo2/0.01)+ (taille2-100)/2) >= points.get(points.size() -1).getY()  ) ?								Math.abs(  (int)(((-posY/zo2/0.01)+ (taille2-100)/2)+6) -  (points.get(points.size() -1).getY()+6 )) :									Math.abs((points.get(points.size()-1).getY()+6) - (int)(((-posY/zo2/0.01)+ (taille2-100)/2)+6)) ;														 b  = ((int)((posX/zo1/0.01)+ taille/2) >= points.get(points.size() -1).getX() ) ?								Math.abs(((int)((posX/zo1/0.01)+ taille/2)+6) - (points.get(points.size()-1).getX()+6)) :									Math.abs((points.get(points.size()-1).getX()+6) - ((int)((posX/zo1/0.01)+ taille/2)+6) );					}										if(!plein)					g.drawOval((points.get(points.size()-1).getX() -b)+6 ,( points.get(points.size()-1).getY()-b)+6 ,							2*b, 							2*b);					else						g.fillOval((points.get(points.size()-1).getX() -b)+6 ,( points.get(points.size()-1).getY()-b)+6 ,								2*b, 								2*b);								 }		}				//bissectrice 		if(bou[2]){		    		    if(!sta){			//Variable pour les equations cartesiennes des 2 droites formé			g.setColor(Color.red);			double a, b ,c , x , y, z= 0 ;						//Facteur de la premiere droite 			a = (points.get(points.size() - 1).getX()+6) - ( points.get(points.size() - 2).getX()+6) ;						b = (points.get(points.size() - 1).getY()+6) -  (points.get(points.size() - 2).getY() +6);						c = a *( points.get(points.size() -1).getX()+6) + b *(points.get(points.size()-1).getY() +6); 			//La deuxieme en fonction de la souris						if(io <= 8 && oi <= 6){							    x =  (int)((posX/z1[incremen]/0.01)+ taille/2) - ( points.get(points.size() - 1).getX()+6) ;			    			    y = (int)((-posY/z2[incremen]/0.01)+ (taille2-100)/2) - (points.get(points.size() - 1).getY()+6) ;						    z = x *( points.get(points.size() -1).getX()+6) + y *(points.get(points.size()-1).getY()+6) ;			}else {			    x =  (int)((posX/zo1/0.01)+ taille/2) -  (points.get(points.size() - 1).getX() +6);			    			    y = (int)((-posY/zo2/0.01)+ (taille2-100)/2) - (points.get(points.size() - 1).getY()+6) ;			    			    z = x *( points.get(points.size() -1).getX()+6) + y *(points.get(points.size()-1).getY() +6);			    			}						//Coefficicents de la bissectrie			double coeffa  , coeffb = 0 ;						coeffa =  -( a/Math.sqrt(a*a + b*b ) +  x/Math.sqrt(x*x + y*y) ) / (b / Math.sqrt(a*a+b*b ) + y / Math.sqrt(x*x + y*y));									coeffb =( c/Math.sqrt(a*a +b*b ) + z/Math.sqrt(x*x + y*y)) / (b/Math.sqrt(a*a +b*b) + y/Math.sqrt(x*x +y*y) ) ; 						g.drawLine(-2 , (int)(coeffa*-2 + coeffb) , 800 , (int)(800*coeffa +coeffb) ) ;					points.get(points.size() -1).min = (int)(coeffa*-2 + coeffb);		points.get(points.size() - 1).max = (int)(800*coeffa +coeffb) ;								    }		}						Stroke stroke = new BasicStroke(2.5f, BasicStroke.CAP_SQUARE,	               BasicStroke.JOIN_MITER, 10.0f);	  	  g.setStroke(stroke);				for(Triangle tr : this.trig){			g.setColor(tr.co);						if(!plein)			g.drawPolygon( tr.tx,tr.ty, 3) ;			else			g.fillPolygon( tr.tx,tr.ty, 3) ;		}												// Ici il s'agit de segments 				int incr = 0 ;		for(Droitee dd : this.droit){			g.setColor(Color.blue);			/*	double coeffaa = (points.get(points.size() - 2 ).getY()   - points.get(points.size() - 1 ).getY()  )/ 				( points.get(points.size() - 2 ).getX() -  points.get(points.size() - 1 ).getX() ) ;								double coeffbb =  points.get(points.size() - 2).getY() - coeffaa * points.get(points.size() - 2).getX() ;								System.out.println(coeffbb);																								g.drawLine(-2 , (int)(coeffaa*-2 + coeffbb) , 800 , (int)(800*coeffaa +coeffbb ) ) ;*/						//	double coeffaa =( dd.getAr().getY() - dd.getDep().getY() )/( dd.getAr().getX() - dd.getDep().getX()) ;						//double coeffbb = dd.getDep().getY() - coeffaa * dd.getDep().getX() ;						//	System.out.println(coeffaa + " et "+ coeffbb);						 									// Demi droite			if(bool.get(incr) == 0){				// Demi droite			    			    if(dd.getDep().getX() < dd.getAr().getX()){			    	g.setColor(Color.yellow);			   				g.drawLine(dd.getDep().getX()+6 , dd.getDep().getY()+6 , 800 , dd.getDep().max ) ;												//g.drawArc(10,100,200,300,200,22);				//g.drawRoundRect(200,200,100,100,100,100);											    }else{			    	g.setColor(Color.orange);				g.drawLine(-2 , dd.getDep().min , dd.getDep().getX()+6 , dd.getDep().getY()+6) ;			    }			    			    			}else if(bool.get(incr) == 1){										    //Trace une droite 				g.setColor(dd.getColo());			    g.drawLine(-2 , dd.getDep().min , 800 , dd.getDep().max ) ;			  //  System.out.println(dd.getAr().getY()+"point depart " + dd.getAr().getX());			    			    //	System.out.println("haer");			    			}			// Cas de la Mediatrice 			else if(bool.get(incr) == 2){				g.setColor(dd.getColo());			    g.drawLine(-2 , dd.getDep().min , 800 , dd.getDep().max ) ;						}			// bissectrice			else if(bool.get(incr) == 3){				g.setColor(dd.getColo());			    g.drawLine(-2 , dd.getDep().min , 800 , dd.getDep().max ) ;						}									incr ++ ;		}				//	g.setColor(Color.green);		//g.fillRect(40,530,10,10);								for(Imagee ima : this.imag){			try {			 ima.setIm(ImageIO.read(new File("picture/"+ima.getNom())));						g.drawImage(ima.getIm() ,ima.getX(),ima.getY() ,ima.getX2() ,ima.getY2(),this);						} catch (IOException e) {						}					}		//Dessin au crayon				for(int kk = 0 ; kk < doot.size() ; kk++){			g.setColor(doot.get(kk).getCol());			//setOpaque( false );						g.fillOval(doot.get(kk).getX() ,doot.get(kk).getY() , doot.get(kk).getLent() ,doot.get(kk).getLent() );				}				 				for(int i = 0 ; i < rect.size() ; i=+2){						g.setColor(r);						if(!plein){				g.drawPolygon(rect.get(i).tx,rect.get(i).ty,4);				g.drawPolygon(rect.get(i+1).tx,rect.get(i+1).ty,4);				if(i+1 < rect.size()){					for(int j = 0 ; j < 4;  j ++){						g.setColor(rect.get(i).getCo());						g.drawLine(rect.get(i).tx[j],rect.get(i).ty[j],rect.get(i+1).tx[j],rect.get(i+1).ty[j] );					}				}			//	g.drawPolygon(cx,cy,4);			}else{				g.fillPolygon(rect.get(i).tx,rect.get(i).ty,4);				g.fillPolygon(cx,cy,4);				if(i+1 < rect.size()){					for(int j = 0 ; j < 4;  j ++){						g.setColor(rect.get(i).getCo());						g.drawLine(rect.get(i).tx[j],rect.get(i).ty[j],rect.get(i+1).tx[j],rect.get(i+1).ty[j] );					}				}			}		}						for(Cercl ce : this.cer){			g.setColor(ce.getCo());			int a = (ce.getAr().getY()>= ce.getDep().getY())? 					Math.abs((ce.getAr().getY()+6 )- (ce.getDep().getY()+6)) :Math.abs((ce.getDep().getY()+6 )- (ce.getAr().getY()+6)) ;					int b = (ce.getAr().getX() >= ce.getDep().getX() ) ?					Math.abs((ce.getAr().getX()+6 )-(ce.getDep().getX()+6)) 					: Math.abs((ce.getDep().getX()+6 )-(ce.getAr().getX()+6)) 					;						if(!plein)					g.drawOval(((ce.getDep().getX()+6)-b) , ((ce.getDep().getY()+6)-b) ,					2*b, 					2*b);			else				g.fillOval(((ce.getDep().getX()+6)-b) , ((ce.getDep().getY()+6)-b) ,						2*b, 						2*b);					}		for(int  i = 0 ; i < paul.size() ; i++){			g.setColor(paul.get(i).colo);			if(!plein)			g.drawPolygon(paul.get(i).pox ,paul.get(i).poy , paul.get(i).poy.length );			else				g.fillPolygon(paul.get(i).pox ,paul.get(i).poy , paul.get(i).poy.length );			}								    }        //800 X 530    //lenx et leny = taille X et Y    public void matrix(){    //x = 800/lenx  530/leny    	int unity = 800/lenx ;    	int unity2 = 530/leny ;    	        	for(int i = 1 ; i < lenx ; i++){    		if(i <= (lenx-2)/2){    			  if(io <= 8 && oi <= 6){    			      			  seg.add(new Segment(  new Points(i*unity  ,260 ,z1[incremen], z2[incremen],20)  , new Points(395  ,((leny/2)-i)*unity2  ,z1[incremen], z2[incremen],20),1 ));    			  seg.add(new Segment(  new Points(i*unity  ,260 ,z1[incremen], z2[incremen],20)  , new Points(395  ,((leny/2)+i)*unity2  ,z1[incremen], z2[incremen],20),1 ));    			  }else{    				  seg.add(new Segment(  new Points(i*unity  ,260 ,zo1, zo2,20)  , new Points(395  ,((leny/2)-i)*unity2  ,zo1, zo2,20),1 ));        			  seg.add(new Segment(  new Points(i*unity  ,260 ,zo1, zo2,20)  , new Points(395  ,((leny/2)+i)*unity2  ,zo1, zo2,20) ,1));	      			  }    			    			    		}else if(i> (lenx-2)/2){    			 if(io <= 8 && oi <= 6){    				 seg.add(new Segment(new Points(i*unity  ,260 ,z1[incremen], z2[incremen],20)  , new Points(395  , (leny - (i-(((lenx-2)/2)+2)))*unity2   ,z1[incremen], z2[incremen],20),1 ));     				 seg.add(new Segment(new Points(i*unity  ,260 ,z1[incremen], z2[incremen],20)  , new Points(395  , ((i - ((lenx-2)/2)-2)   )*unity2   ,z1[incremen], z2[incremen],20),1 ));     				     			 }else{    				     				 seg.add(new Segment(new Points(i*unity  ,260 ,zo1, zo2,20)  , new Points(395  , (leny - (i-(((lenx-2)/2)+2)))*unity2   ,zo1, zo2,20),1 ));     				 seg.add(new Segment(new Points(i*unity  ,260 ,zo1, zo2,20)  , new Points(395  , ((i - ((lenx-2)/2)-2)   )*unity2   ,zo1, zo2,20),1 ));      			 }    		}    	}    	    }        /*     * accesseurs et mutateur     */        public int getTaille(){	return taille ;    }    public void setTaille(int n){	this.taille = n ;    }    public int getTaille2(){	return taille2 ;    }        public void setTaille2(int n){				this.taille2 = n ;    }        public void setFonc(String a){	this.fonc = a ;    }    public String getFonc(){	return fonc ;    }        public double getZo1() {		return zo1;	}	public void setZo1(double zo1) {		this.zo1 = zo1;	}	public double getZo2() {		return zo2;	}	public void setZo2(double zo2) {		this.zo2 = zo2;	}    public double getOi() {		return oi;	}	public void setOi(double oi) {		this.oi = oi;	}	public double getIo() {		return io;	}	public void setIo(double io) {		this.io = io;	}	public int getLenx() {		return lenx;	}	public void setLenx(int lenx) {		this.lenx = lenx;	}	public int getLeny() {		return leny;	}	public void setLeny(int leny) {		this.leny = leny;	}			/*	 * @param coordonée X et Y	 * renvoie l'objet détécté	 */		public boolean select(int getx , int gety) {		for(int i = 0 ; i < droit.size() ; i++){			if(gety <=  droit.get(i).getQ()*getx+ droit.get(i).getR() +10 && gety >=  droit.get(i).getQ()*getx+ droit.get(i).getR() -10 ){				droit.get(i).setColo(Color.blue) ;				droit.get(i).select = true ;				selection.add(droit.get(i));				confirm=true ;				return true ;			}		}				for(int  i =0 ; i < points.size() ; i++){			if(getx <=  points.get(i).getX()+10 && getx >=  points.get(i).getX()-10 					&& gety <=  points.get(i).getY()+10 && gety >=  points.get(i).getY()-10 ){				points.get(i).setColor(Color.RED);				selection.add(points.get(i));				confirm=true ;												return true ;			}				}				return false;	}	  }